#+TITLE: SICP
#+AUTHOR: Andrew Michael
#+BABEL: 

------------------------

* Building Abstractions with Procedures
** 1.1: Elements of Programming
*** Exercise 1.8 - Approximating cubic roots
$$\frac{\frac{x}{y^3}+2y}{3}$$
#+begin_src scheme :session *guile*
  (define (cbrt x)
    (cbrt-iter 1.0 x))
  (define (cbrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (cbrt-iter (improve guess x) x)))
  (define (improve guess x)
    (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
  (define (good-enough? guess x)
    (< (abs (- (expt guess 3) x)) 0.001))

  (cbrt 39837)
#+end_src

#+RESULTS:
: 34.15300134325344

*** Lexical Scoping - Internal Definitions

The above exercise, but organized under one definition:
#+begin_src scheme :session *guile*
  (define (cbrt x)  
    (define (cbrt-iter guess x)
      (let ((improve (lambda (guess x)
                       (/ (+ (/ x (expt guess 2)) (* 2 guess)) 3)))
            (good-enough? (lambda (guess x)
                            (< (abs (- (expt guess 3) x)) 0.001))))
        (if (good-enough? guess x)
            guess
            (cbrt-iter (improve guess x) x))))
    (cbrt-iter 1.0 x))

    (cbrt 39837)
#+end_src

#+RESULTS:
: 34.15300134325344

** 1.2: Procedures and Processes
This chapter examines linear recursion and iteration, as well as the term /procedure/ and what it means for local and global transformations of patterns. Specifically, recursive processes and linear processes have different "shapes". They relate to the elements of computation differently in how the procedure carries out through time and (memory) space.

Recursive processes defer a chain of operations and then rapidly contract. A function that calls itself as an operation generate a recursive process.

Example: for computing a factorial ($n!$), the number of steps would grow linearly with $n$. 

An iterative process would not "contract" in this manner-- it simply keeps track of a fixed number of variable values and then re-iterates, generating a number of steps in finite-memory in which the variables are updated according to a fixed rule.

A function defined in terms of itself is not necessarily recursive. It could be iterative as well. The difference is whether the function calls itself as an argument in an expression (recursive) or simply calls itself with adjustments to variable values (iterative). Ultimately, a recursive process has to negotiate an increasing amount of information (steps /and/ memory grow proportional to the input) whereas an interative process captures the state all at once in each step and starts fresh. The information remains fixed, only the number of steps remain proportional to input. 

An example:

#+begin_src scheme
   ;; a recursive factorial function
    (define (fact-r n)
      (if (= n 0)
          1
          (* n (fact-r (- n 1)))))
    ;; an iterative factorial function
    (define (fact-i n)
      (letrec ((iter
             (lambda (n product)
               (if (= 1 n)
                   product
                   (iter (- n 1) (* product n))))))
        (iter n 1)))

#+end_src

#+RESULTS:
: An error occurred.

Aside on binding constructs:

=letrec= was not introduced at this point in the book. I used =letrec= in place of a "helper" iteration function.

- binding :: binding is the relationship between the name of something and its location in memory.
- =let= :: a derived form of =lambda=. =let= directly assigns an identifier to the result of an expression; =lambda= is passed identifiers. These are equivalent:
#+begin_src scheme :results no
  ((lambda (param1 param2 ... ) body) var1 var2 ... )
  (let ([param1 var1] [param2 var2] ... ) body)
#+end_src
- =let*= :: evaluates all declared bindings sequentially, that is, with respect to those that were declared before it. Normal =let= binds ids in parrallel.
- =letrec=  :: allows the binding of recursive functions. See: http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html

As an aside, proper dialects of Scheme are /tail-recursive/-- that is, a compiler trick allows for computationally cheap recursive function calls. This is different from many imperative programming languages in which iteration is almost always preffered to recursion. 

Some Schemes feature a useful macro called "named let" that mirrors particular uses of =letrec=.

*** Fibonacci numbers
#+begin_src scheme :session *guile*

#+end_src

Approximating $\varphi$:

* Building Abstractions with Data
* Modularity, Objects, and State

